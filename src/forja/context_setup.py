"""Forja context setup - interactive wizard for company, domain, and design system."""

from __future__ import annotations

import json
import re
import shutil
from pathlib import Path

from forja.utils import (
    BOLD,
    CYAN,
    DIM,
    GREEN,
    RED,
    RESET,
    PASS_ICON,
    WARN_ICON,
    call_kimi,
    load_dotenv,
    parse_json,
)

# ── Path safety ──────────────────────────────────────────────────────

_BLOCKED_PATH_SEGMENTS = {
    ".ssh", ".gnupg", ".aws", ".azure", ".kube", ".docker",
    ".password-store", ".config/gcloud",
}

_SAFE_DOC_EXTENSIONS = {".md", ".json", ".txt", ".yaml", ".yml", ".csv", ".pdf"}


def _is_safe_doc_path(path: Path) -> bool:
    """Return True if *path* is safe to copy as documentation.

    Blocks sensitive directories and restricts to known doc extensions.
    """
    resolved = str(path.resolve())
    for segment in _BLOCKED_PATH_SEGMENTS:
        if f"/{segment}/" in resolved or resolved.endswith(f"/{segment}"):
            return False
    # System config/data directories are never doc sources
    # (include /private/ variants for macOS)
    for prefix in ("/etc/", "/private/etc/",
                   "/var/log/", "/var/lib/", "/var/run/",
                   "/private/var/log/", "/private/var/lib/", "/private/var/run/"):
        if resolved.startswith(prefix):
            return False
    return True

# ── Input helpers ────────────────────────────────────────────────────


def _ask(prompt: str, default: str = "") -> str:
    """Ask the user a question. Returns answer or default."""
    try:
        suffix = f" ({default})" if default else ""
        answer = input(f"  {BOLD}{prompt}{suffix}:{RESET} ").strip()
        return answer if answer else default
    except (EOFError, KeyboardInterrupt):
        print()
        return default


def _ask_choice(prompt: str, options: list[tuple[str, str]], default: int = 1) -> tuple[int, str]:
    """Show numbered options, return (index, label). 1-indexed."""
    print(f"\n  {BOLD}{prompt}{RESET}")
    for i, (label, _desc) in enumerate(options, 1):
        marker = f"{GREEN}({i}){RESET}" if i == default else f"  ({i})"
        print(f"    {marker} {label}")
    try:
        raw = input(f"  {BOLD}>{RESET} ").strip()
    except (EOFError, KeyboardInterrupt):
        print()
        raw = ""
    idx = int(raw) if raw.isdigit() and 1 <= int(raw) <= len(options) else default
    return idx, options[idx - 1][0]


def _ask_multiline(prompt: str) -> list[str]:
    """Get multiple lines until empty line."""
    print(f"  {BOLD}{prompt}{RESET}")
    lines: list[str] = []
    while True:
        try:
            line = input(f"  {DIM}>{RESET} ").strip()
        except (EOFError, KeyboardInterrupt):
            print()
            break
        if not line:
            break
        lines.append(line)
    return lines


# ── Constants ────────────────────────────────────────────────────────

AUTO_HEADER = "<!-- Auto-generated by Forja. Replace with your own content for better results. -->\n\n"

AUDIENCE_OPTIONS = [
    ("Enterprise / B2B", "enterprise"),
    ("Financial Services", "financial-services"),
    ("Government", "government"),
    ("Healthcare", "healthcare"),
    ("Consumers / B2C", "consumers"),
    ("Developers / API users", "developers"),
    ("Other (describe)", "other"),
    ("Skip", "skip"),
]


# ── Company setup ────────────────────────────────────────────────────


def _setup_company(target: Path) -> tuple[str | None, str | None]:
    """Step 1: Company context. Returns (name, description) or (None, None)."""
    print(f"\n{BOLD}── Context Setup ──{RESET}")
    print(f"  {DIM}Let's set up your project context.{RESET}\n")

    name = _ask("Company name (or project name)")
    if not name:
        return None, None

    desc = _ask("Describe your company/project in 2-3 sentences")
    if not desc:
        desc = name

    docs_path = _ask("Paste path to existing company docs (or enter to generate)")

    company_dir = target / "context" / "company"
    company_dir.mkdir(parents=True, exist_ok=True)

    if docs_path and Path(docs_path).exists():
        src = Path(docs_path)
        if not _is_safe_doc_path(src):
            print(f"  {RED}Blocked: {docs_path} looks like a sensitive directory.{RESET}")
        elif src.is_file() and src.suffix in _SAFE_DOC_EXTENSIONS:
            shutil.copy2(str(src), str(company_dir / src.name))
            print(f"  {PASS_ICON} Copied {src.name} to context/company/")
        elif src.is_dir():
            copied = 0
            for f in sorted(src.iterdir()):
                if f.is_file() and f.suffix in _SAFE_DOC_EXTENSIONS and _is_safe_doc_path(f):
                    shutil.copy2(str(f), str(company_dir / f.name))
                    copied += 1
            print(f"  {PASS_ICON} Copied {copied} doc(s) to context/company/")
        else:
            print(f"  {DIM}Skipped: unsupported file type ({src.suffix}){RESET}")

    if not docs_path or not Path(docs_path).exists():
        print(f"  {DIM}Generating company overview...{RESET}")
        messages = [
            {"role": "system", "content": "You respond only with the requested content. No preamble."},
            {"role": "user", "content": (
                f"Generate a concise company overview for a software project. "
                f"Company: {name}. Description: {desc}. "
                f"Include: what the company does, target market, key differentiators, tech philosophy. "
                f"Max 30 lines markdown."
            )},
        ]
        raw = call_kimi(messages)
        if raw:
            overview = AUTO_HEADER + raw.strip() + "\n"
        else:
            overview = (
                AUTO_HEADER +
                f"# {name}\n\n{desc}\n\n"
                "## Target Market\n[PENDING]\n\n"
                "## Key Differentiators\n[PENDING]\n\n"
                "## Tech Philosophy\n[PENDING]\n"
            )
        (company_dir / "company-overview.md").write_text(overview, encoding="utf-8")
        print(f"  {PASS_ICON} Generated context/company/company-overview.md")

    return name, desc


# ── Domain setup ─────────────────────────────────────────────────────


def _setup_domain(target: Path, name: str, desc: str) -> str | None:
    """Step 2: Domain context. Returns domain_slug or None."""
    idx, label = _ask_choice("Who is the target audience?", AUDIENCE_OPTIONS, default=1)
    domain_slug = AUDIENCE_OPTIONS[idx - 1][1]

    if domain_slug == "skip":
        return None

    if domain_slug == "other":
        custom = _ask("Describe target audience")
        domain_slug = re.sub(r"[^a-z0-9]+", "-", custom.lower()).strip("-") or "custom"

    value_prop = _ask("What is the main value proposition? (one sentence)")
    objections = _ask_multiline("Top objections your audience has? (one per line, empty to finish)")

    domain_dir = target / "context" / "domains" / domain_slug
    domain_dir.mkdir(parents=True, exist_ok=True)

    audience_label = label if domain_slug != "other" else domain_slug
    obj_text = "\n".join(f"- {o}" for o in objections) if objections else "- None specified"

    print(f"  {DIM}Generating domain context...{RESET}")
    messages = [
        {"role": "system", "content": "You are a domain expert. Respond only with valid JSON."},
        {"role": "user", "content": (
            f"Generate domain context files for a {audience_label} software project.\n"
            f"Company: {name} - {desc}\n"
            f"Audience: {audience_label}\n"
            f"Value prop: {value_prop}\n"
            f"Objections:\n{obj_text}\n\n"
            f"Generate 3 files as JSON:\n"
            f'{{\n'
            f'  "domain_md": "DOMAIN.md content - bounded context with: primary driver, '
            f'audience table (roles + top concerns), competitor benchmarks (generic for this industry), '
            f'anti-patterns (what NOT to do/say), key messages. Max 40 lines.",\n'
            f'  "value_props_md": "value-props.md content - main value prop expanded + 3 secondary props '
            f'with proof points and quotes per audience role. Max 50 lines.",\n'
            f'  "objections_md": "objections.md content - each objection with response strategy '
            f'and supporting data points. Max 30 lines."\n'
            f'}}'
        )},
    ]

    raw = call_kimi(messages)
    if raw:
        data = parse_json(raw)
        if data:
            for key, fname in [("domain_md", "DOMAIN.md"), ("value_props_md", "value-props.md"),
                               ("objections_md", "objections.md")]:
                content = data.get(key, "")
                if content:
                    (domain_dir / fname).write_text(AUTO_HEADER + content + "\n", encoding="utf-8")
            print(f"  {PASS_ICON} Generated context/domains/{domain_slug}/ (3 files)")
            return domain_slug

    # Fallback: placeholder templates
    (domain_dir / "DOMAIN.md").write_text(
        AUTO_HEADER + f"# {audience_label} Domain\n\n"
        f"## Primary Driver\n{value_prop or '[PENDING]'}\n\n"
        f"## Audience\n[PENDING]\n\n## Anti-patterns\n[PENDING]\n",
        encoding="utf-8",
    )
    (domain_dir / "value-props.md").write_text(
        AUTO_HEADER + f"# Value Propositions\n\n## Main\n{value_prop or '[PENDING]'}\n",
        encoding="utf-8",
    )
    (domain_dir / "objections.md").write_text(
        AUTO_HEADER + f"# Objection Handling\n\n{obj_text}\n",
        encoding="utf-8",
    )
    print(f"  {PASS_ICON} Generated context/domains/{domain_slug}/ (placeholders)")
    return domain_slug


# ── Color complement ─────────────────────────────────────────────────


def _complement_color(hex_color: str) -> str:
    """Generate a complementary accent color from primary."""
    hex_color = hex_color.lstrip("#")
    try:
        r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
        cr, cg, cb = (r + 128) % 256, (g + 85) % 256, (b + 170) % 256
        return f"#{cr:02x}{cg:02x}{cb:02x}"
    except (ValueError, IndexError):
        return "#6366f1"


# ── Design system setup ──────────────────────────────────────────────


def _setup_design_system(target: Path, name: str) -> None:
    """Step 3 (landing-page only): Design system setup."""
    print(f"\n{BOLD}── Design System ──{RESET}")

    docs_path = _ask("Do you have a design system or brand guidelines? (paste path, or enter to configure)")

    ds_dir = target / "context" / "design-system"
    ds_dir.mkdir(parents=True, exist_ok=True)
    brand_dir = target / "context" / "company" / "brand-assets"
    brand_dir.mkdir(parents=True, exist_ok=True)

    if docs_path and Path(docs_path).exists():
        src = Path(docs_path)
        if not _is_safe_doc_path(src):
            print(f"  {RED}Blocked: {docs_path} looks like a sensitive directory.{RESET}")
        elif src.is_file() and src.suffix in _SAFE_DOC_EXTENSIONS:
            shutil.copy2(str(src), str(ds_dir / src.name))
            print(f"  {PASS_ICON} Copied {src.name} to context/design-system/")
            return
        elif src.is_dir():
            copied = 0
            for f in sorted(src.iterdir()):
                if f.is_file() and f.suffix in _SAFE_DOC_EXTENSIONS and _is_safe_doc_path(f):
                    shutil.copy2(str(f), str(ds_dir / f.name))
                    copied += 1
            print(f"  {PASS_ICON} Copied {copied} doc(s) to context/design-system/")
            return
        else:
            print(f"  {DIM}Skipped: unsupported file type ({src.suffix}){RESET}")

    primary = _ask("Primary brand color (hex, e.g. #00E5B0)", "#00E5B0")
    if not primary.startswith("#"):
        primary = f"#{primary}"

    secondary_input = _ask("Secondary/accent color (hex, or enter for auto-complement)")
    if secondary_input:
        secondary = secondary_input if secondary_input.startswith("#") else f"#{secondary_input}"
    else:
        secondary = _complement_color(primary)
        print(f"  {DIM}Auto-generated accent: {secondary}{RESET}")

    font = _ask("Font family (e.g. Inter, Poppins)", "Inter")

    style_options = [
        ("Dark & modern", "dark backgrounds, bright accents"),
        ("Light & clean", "white backgrounds, subtle colors"),
        ("Bold & colorful", "gradients, multiple colors"),
        ("Minimal", "lots of whitespace, simple"),
    ]
    style_idx, style_label = _ask_choice("Visual style?", style_options, default=1)
    style_key = ["dark-modern", "light-clean", "bold-colorful", "minimal"][style_idx - 1]

    # Generate colors.json
    colors = {
        "primary": primary,
        "secondary": secondary,
        "style": style_key,
        "backgrounds": {
            "main": "#0a0a0a" if "dark" in style_key else "#ffffff",
            "surface": "#1a1a2e" if "dark" in style_key else "#f8f9fa",
            "elevated": "#16213e" if "dark" in style_key else "#ffffff",
        },
        "text": {
            "primary": "#ffffff" if "dark" in style_key else "#1a1a2e",
            "secondary": "#a0a0b0" if "dark" in style_key else "#6b7280",
            "accent": primary,
        },
        "borders": {
            "default": "rgba(255,255,255,0.1)" if "dark" in style_key else "rgba(0,0,0,0.1)",
            "accent": primary,
        },
    }
    (brand_dir / "colors.json").write_text(
        json.dumps(colors, indent=2, ensure_ascii=False) + "\n", encoding="utf-8"
    )
    print(f"  {PASS_ICON} Generated context/company/brand-assets/colors.json")

    # Generate typography.json
    typography = {
        "family": font,
        "import_url": f"https://fonts.googleapis.com/css2?family={font.replace(' ', '+')}:wght@400;500;600;700&display=swap",
        "sizes": {
            "hero": "4rem", "h1": "3rem", "h2": "2rem", "h3": "1.5rem",
            "body": "1.125rem", "small": "0.875rem", "caption": "0.75rem",
        },
        "weights": {"normal": 400, "medium": 500, "semibold": 600, "bold": 700},
        "line_heights": {"tight": 1.2, "normal": 1.5, "relaxed": 1.75},
    }
    (brand_dir / "typography.json").write_text(
        json.dumps(typography, indent=2, ensure_ascii=False) + "\n", encoding="utf-8"
    )
    print(f"  {PASS_ICON} Generated context/company/brand-assets/typography.json")

    # Generate DESIGN-REFERENCE.md via Kimi
    print(f"  {DIM}Generating design reference...{RESET}")
    messages = [
        {"role": "system", "content": "You respond only with the requested content. No preamble."},
        {"role": "user", "content": (
            f"Generate a design reference guide for a {style_label} landing page. "
            f"Primary color: {primary}. Secondary/accent: {secondary}. Font: {font}. "
            f"Include: color palette with CSS variables, typography scale, layout patterns "
            f"(section structure), component patterns (buttons, cards, navigation), "
            f"spacing rules, illustration style recommendations, list of things NOT to do. "
            f"Format as markdown. Max 80 lines."
        )},
    ]
    raw = call_kimi(messages)
    if raw:
        ref_content = AUTO_HEADER + raw.strip() + "\n"
    else:
        ref_content = (
            AUTO_HEADER +
            f"# Design Reference - {style_label}\n\n"
            f"## Colors\n- Primary: {primary}\n- Secondary: {secondary}\n"
            f"- Background: {colors['backgrounds']['main']}\n\n"
            f"## Typography\n- Font: {font}\n- Hero: 4rem, H1: 3rem, H2: 2rem, Body: 1.125rem\n\n"
            f"## Layout\n[PENDING]\n\n## Components\n[PENDING]\n\n"
            f"## Do NOT\n[PENDING]\n"
        )
    (ds_dir / "DESIGN-REFERENCE.md").write_text(ref_content, encoding="utf-8")
    print(f"  {PASS_ICON} Generated context/design-system/DESIGN-REFERENCE.md")


# ── Tech stack setup ─────────────────────────────────────────────────


def _setup_tech_stack(target: Path, name: str, desc: str) -> None:
    """Step 3 (api-backend only): Tech stack setup."""
    print(f"\n{BOLD}── Tech Stack ──{RESET}")

    stack = _ask(
        "Tech stack preferences? (e.g. 'Python + FastAPI + PostgreSQL' or enter for default)",
        "Python + FastAPI + SQLAlchemy + SQLite",
    )

    company_dir = target / "context" / "company"
    company_dir.mkdir(parents=True, exist_ok=True)
    (company_dir / "tech-stack.md").write_text(
        AUTO_HEADER + f"# Tech Stack\n\n{stack}\n",
        encoding="utf-8",
    )
    print(f"  {PASS_ICON} Saved context/company/tech-stack.md")


# ── Index generation ─────────────────────────────────────────────────


def _generate_index(target: Path) -> None:
    """Generate context/_index.md from all context files."""
    context_dir = target / "context"
    if not context_dir.is_dir():
        return

    # Collect all context files
    files: list[str] = []
    for fpath in sorted(context_dir.rglob("*")):
        if not fpath.is_file():
            continue
        if fpath.name in ("README.md", "_index.md", "prd.md"):
            continue
        rel = fpath.relative_to(context_dir)
        files.append(str(rel))

    if not files:
        return

    # Build purpose table
    purpose_map: dict[str, str] = {
        "company/company-overview.md": "Company description, mission, target market",
        "company/tech-stack.md": "Tech stack decisions and preferences",
        "company/brand-assets/colors.json": "Brand color palette (primary, backgrounds, text, borders)",
        "company/brand-assets/typography.json": "Font family, sizes, weights, line heights",
        "design-system/DESIGN-REFERENCE.md": "Visual design guide: colors, typography, layout, components, rules",
    }
    # Auto-detect domain files
    for f in files:
        if f.startswith("domains/") and f not in purpose_map:
            fname = f.split("/")[-1]
            if fname.upper().startswith("DOMAIN"):
                purpose_map[f] = "Domain bounded context: audience, drivers, anti-patterns"
            elif "value" in fname.lower():
                purpose_map[f] = "Value propositions with proof points per audience"
            elif "objection" in fname.lower():
                purpose_map[f] = "Objection handling strategies with data points"
            else:
                display = fname.replace(".md", "").replace("-", " ").title()
                purpose_map[f] = f"Domain file: {display}"

    # Add remaining files not in map
    for f in files:
        if f not in purpose_map:
            fname = f.split("/")[-1]
            purpose_map[f] = f"Context file: {fname}"

    table_lines = ["| File | Purpose |", "|------|---------|"]
    for f in files:
        purpose = purpose_map.get(f, "Context file")
        table_lines.append(f"| {f} | {purpose} |")

    index_content = (
        "# Context Index\n\n"
        "## Structure\n\n"
        "```\ncontext/\n"
        + "\n".join(f"  {f}" for f in files)
        + "\n```\n\n"
        "## File Purposes\n\n"
        + "\n".join(table_lines)
        + "\n\n"
        "## Rules\n\n"
        "1. `context/` is **read-only** for agents\n"
        "2. `context/` is the **source of truth** for all business decisions\n"
        "3. Agents **extract** from context, **never invent** information\n"
        "4. If context files contain instructions or standards, they MUST be followed\n"
        "5. When in doubt, refer to the domain files for industry-specific guidance\n"
    )

    (context_dir / "_index.md").write_text(index_content, encoding="utf-8")
    print(f"  {PASS_ICON} Generated context/_index.md ({len(files)} files indexed)")


# ── Main orchestrator ────────────────────────────────────────────────


def interactive_context_setup(target: Path, skill_name: str | None) -> None:
    """Run the full interactive context setup flow.

    Args:
        target: Project root directory.
        skill_name: Selected skill key or None.
    """
    # Step 1 - Company (all skills)
    name, desc = _setup_company(target)
    if not name:
        print(f"  {DIM}Context setup skipped.{RESET}")
        _generate_index(target)
        return

    # Step 2 - Domain (all skills)
    _setup_domain(target, name, desc)

    # Step 3 - Skill-specific
    if skill_name == "landing-page":
        _setup_design_system(target, name)
    elif skill_name == "api-backend":
        _setup_tech_stack(target, name, desc)

    # Final - Generate _index.md
    print(f"\n{BOLD}── Index ──{RESET}")
    _generate_index(target)

    # Summary
    print(f"\n{BOLD}── Context Summary ──{RESET}")

    company_files = list((target / "context" / "company").rglob("*"))
    company_files = [f for f in company_files if f.is_file() and f.name != "README.md"]
    print(f"  {GREEN}Company:{RESET} {len(company_files)} file(s)")

    domains_dir = target / "context" / "domains"
    if domains_dir.is_dir():
        domain_files = [f for f in domains_dir.rglob("*") if f.is_file() and f.name != "README.md"]
        if domain_files:
            print(f"  {GREEN}Domain:{RESET} {len(domain_files)} file(s)")

    ds_dir = target / "context" / "design-system"
    ds_files = [f for f in ds_dir.rglob("*") if f.is_file() and f.name != "README.md"] if ds_dir.is_dir() else []
    if ds_files:
        print(f"  {GREEN}Design:{RESET} {len(ds_files)} file(s)")

    print(f"  {GREEN}Index:{RESET} _index.md")
    print(f"\n  {DIM}You can replace any auto-generated file with your own.{RESET}")
    print(f"  {BOLD}Run 'forja plan' to refine the PRD with expert review.{RESET}")
